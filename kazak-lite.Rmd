```{r echo=FALSE}
library(knitr)
opts_chunk$set(echo=FALSE)
```

---
title: "IL-2 Influences of the Transcriptional Activity in Human MSC"
author: "Lu Wang"
date: "Monday, July 21, 2014"
output: html_document
---
## Experimental Design

![Experimental Design][img01]

## Libraries and Raw Data

In this analysis, we started with `.bam` files containing RNA-seq reads aligned to hg19. The first metadata file is the `libs` file which contains the name and total mapped reads of all libraries.

```{r cache=TRUE}
libs <- read.delim("./kazak_data/tmap_lib_size.tsv", header=TRUE,sep="\t")
```

```{r colors}
library(RColorBrewer)
c6 <- brewer.pal(6, "Paired")
c6 <- c6[c(2, 1, 6, 5, 4, 3)]

pal1 <- colorRampPalette(c6[1:2])
pal2 <- colorRampPalette(c6[3:4])
pal3 <- colorRampPalette(c6[5:6])

c15 <- c(pal1(7)[c(1:2, 5:7)], pal2(6)[c(1:2, 5:6)], pal3(8)[c(1:3, 6:8)])
```

In this data set, we have **`r nrow(libs)`** sequencing runs that correspond to **six** different RNA libraries/conditions:

1. SR
2. SR with IL-2 treatment
3. SEN
4. SEN with IL-2 treatment
5. REJ
6. REJ with IL-2 treatment

Each file contains mapped reads were pooled together, compared against RefSeq gene model(`RefSeq.bed` file downloaded from UCSC genome browser) and generated a counts matrix using `bedtools`. 

## Distribution of Raw Counts

The raw counts for each transcript is calculated by couting the number of reads overlapped with the **exons** of both protein-coding and non-coding **RefSeq transcripts**.

```{r readCountsMatrix, cache=TRUE}
tb <- read.table("./kazak_data/counts_matrix.txt",header=FALSE)
counts <- as.matrix(tb[,2:16])
rownames(counts) <- tb[,1]
rm(tb)
colnames(counts) <- rownames(libs)
counts <- counts[order(rownames(counts)),]
head(counts, n=2)
```


```{r CountsDensity}
library(reshape)
library(ggplot2)

plotDistribution <- function(data, title = ""){
    par(mar=c(8.1,6.1,4.1,2.1))
    par(las=2)
    boxplot(log2(data.frame(data)), col = c15, names = (colnames(data)), main = paste(title))
    data.df <- data.frame(id = rownames(data), data, stringsAsFactors = FALSE)
    mdf <- melt(data.df, id = "id", variable_name = "condition")

    ggplot(mdf, aes(log2(value))) +
        geom_density(aes(color = condition)) + 
        title(main = paste(title), xlab = "") + 
        scale_colour_manual(values = c15) +
        theme_bw() +
        theme(panel.grid.major = element_blank())
}

plotDistribution(counts+1, "Distribution of Read Counts")
```

In this analysis, **technical replicates for each condition were combined** to increase the total signal. We started with **`r nrow(counts)`** RefSeq transcript annotations.

```{r filterLibs, fig.width = 6}
c15 <- c6
sr_tr = grep("sr_treated", colnames(counts))
sr_un = grep("sr_untreated", colnames(counts))
sen_tr = grep("sen_treated", colnames(counts))
sen_un = grep("sen_untreated", colnames(counts))
rej_tr = grep("rej_treated", colnames(counts))
rej_un = grep("rej_untreated", colnames(counts))


counts <- data.frame( sr_treated = apply(counts[, sr_tr], 1, sum),
                      sr_untreated = apply(counts[, sr_un], 1, sum),
                      sen_treated = apply(counts[, sen_tr], 1, sum),
                      sen_untreated = apply(counts[, sen_un], 1, sum),
                      rej_treated = apply(counts[, rej_tr], 1, sum),
                      rej_untreated = apply(counts[, rej_un], 1, sum))
head(counts, 2)
plotDistribution(counts+1, "Distribution of Read Counts")
```

## ERCC Counts

The ERCC counts for each library were downloaded from the **Ion Proton** server with the help from James. The distribution of ERCC counts is shown below:

```{r readERCC, fig.width = 6}
ercc <- read.table("./kazak_data/ercc_counts.txt", header = TRUE)

ercc <- data.frame( sr_treated = apply(ercc[, sr_tr], 1, sum),
                    sr_untreated = apply(ercc[, sr_un], 1, sum),
                    sen_treated = apply(ercc[, sen_tr], 1, sum),
                    sen_untreated = apply(ercc[, sen_un], 1, sum),
                    rej_treated = apply(ercc[, rej_tr], 1, sum),
                    rej_untreated = apply(ercc[, rej_un], 1, sum))
head(ercc, 2)

plotDistribution(ercc+1, "Distribution of ERCC Counts")
```

In general, the distribution of **`r nrow(ercc)`**ERCC counts follows the trend of total read counts.

## Determining Lower Limit of Detection

The true counts of the ERCC sequences were obtaind from the `ERCC_Controls_Analysis.txt` file downloaded from [manufacturer's website][001]

```{r downloadERCC, cache = TRUE}
con = "http://tools.lifetechnologies.com/downloads/ERCC_Controls_Analysis.txt"
true.ercc <- read.delim(con, header = TRUE)
```

The scatterplots below compared the observed ERCC counts versus the theoretical number of molecules from the manufacturer's documentation.

```{r reformatERCC}
true.ercc <- true.ercc[, c(2, 4)]
true.ercc <- true.ercc[order(true.ercc$ERCC.ID), ]

head(true.ercc)
colnames(true.ercc) = c("ercc.id", "mix1.attmoles")
```


```{r obsERCCvsTrue, fig.height = 6, fig.width = 9}
library(reshape)
library(lattice)

low.cut <- 3
lib.cut <- 2

ercc.df <- cbind(ercc.id = rownames(ercc), ercc, stringsAsFactors = FALSE)

erccOvsE <- function(data, title = ""){
    temp <- merge(data, true.ercc, by.x = colnames(data)[grep("id", colnames(data))], by.y = "ercc.id")
    
    mdf <- melt(temp[, c(1, grep("sr|sen|rej", colnames(temp)))], id = colnames(data)[grep("id", colnames(data))], variable_name = "sample")
    
    mdf <- cbind(mdf, expected = rep(temp$mix1.attmoles, ncol(ercc)))
    
    mdf$sample <- ordered(mdf$sample)
    
    xyplot( log2(value + 1) ~ log2(expected+1) | sample, data = mdf, 
            layout = c(3,2), 
            as.table = TRUE, 
            pch = 20, 
            col = rgb(70, 130, 180, 100, maxColorValue = 255), 
            par.strip.text = list(cex = 0.7), 
            xlim = c(0, 15),
            ylim = c(0, 15),
            xlab = expression(log[2]*"Expected Counts"), 
            ylab = expression(log[2]*"Observed Counts"), 
            main = paste(title), 
            panel = function(x, y, ...) {
                panel.xyplot(x, y, ...)
                panel.abline(h = log2(low.cut+1), lty = 2)
                panel.lmline(x, y, col.line = rgb(0,0,0,0.2))
    })
}
erccOvsE(ercc.df, "ERCC Dose Response")
```

The **dashed line** in panels above shows the empirical cutoff for low read count sequences. The ERCC sequences with more than **`r low.cut`** counts in each library demonstrated linear relationship between the expected and observed read counts.

```{r plotPairwiseCorr, fig.height = 9, fig.width = 12}
plotPairs <- function(data, title = ""){
    pairs(log2(data), col = rgb(0,0.5,1,0.2), pch = 16, main = paste(title))
}
```


# Normalization

```{r exonLengths, cache=TRUE}
exon.lengths <- t(read.delim("./kazak_data/exon_lengths.tsv",header=TRUE,sep="\t"))
```

The exon length of each RefSeq transcripts were calculated using the `RefSeq.gtf` file downloaded from UCSC genome browser. 

```{r getGeneLengths}
counts.df <- data.frame(id = rownames(counts), counts, stringsAsFactors = FALSE)
lengths.df <- data.frame(id = rownames(exon.lengths), exon.lengths)
mdf <- merge(counts.df, lengths.df, by.x = "id", by.y = "id")
counts.df <- mdf
head(counts.df, 2)
```

For ERCC Spike-Ins, the lengths of the ERCC sequences were obtaind from the `ERCC92.gtf` file downloaded from [manufacturer's website][001]

```{r getERCClength}
tb <- read.table("http://tools.invitrogen.com/downloads/ERCC92.gtf", header = FALSE)
tb <- tb[, c(1, 5)]
colnames(tb) <- c("id", "length")
mdf <- merge(ercc.df, tb, by.x = "ercc.id", by.y = "id" )
ercc.df <- mdf
head(ercc.df, 2)
```


```{r RefSeq2HGNC_symbol, cache = TRUE}
library(biomaRt)


pcg <- grep("NM_", counts.df$id)
nc <- grep("NR_", counts.df$id)

pcg.id <- counts.df$id[pcg]
nc.id <- counts.df$id[nc]

getSymbol <- function(ids, id.type, attributes){
    ensembl = useMart("ensembl", dataset = "hsapiens_gene_ensembl")
    res <- getBM( attributes = c(paste(id.type), paste(attributes)), filters = id.type, values = ids, mart = ensembl )
}


res1 <- getSymbol(pcg.id, "refseq_mrna", attributes = "hgnc_symbol")
res2 <- getSymbol(nc.id, "refseq_ncrna", attributes = "hgnc_symbol")
```

```{r cleanHGNC_symbol}
cleanBiomartRes <- function(data, id.type, attribute){
    # Remove nchar=0 empty results
    data[, attribute] <- ifelse(nchar(data[, paste(attribute)]) == 0, NA, data[, attribute])
    # Sort and remove duplicated id
    data <- data[order(data[, id.type], data[, attribute]), ]
    data <- data[!duplicated(data[, id.type]), ]
}
res1 <- cleanBiomartRes(res1, "refseq_mrna", "hgnc_symbol")
res2 <- cleanBiomartRes(res2, "refseq_ncrna", "hgnc_symbol")
```

```{r assembleHGNC_symbol}
#Assemble results for mRNA
pcg <- merge(counts.df[pcg, ], res1, by.x = "id", by.y = "refseq_mrna", all.x = TRUE)

fillMissingSymbol <- function(data){
    data$hgnc_symbol <- ifelse(is.na(data$hgnc_symbol), data$id, data$hgnc_symbol)
    return(data)
}
pcg <- fillMissingSymbol(pcg)
#rm(res1)

#Assemble results for ncRNA
nc <- merge(counts.df[nc, ], res2, by.x = "id", by.y = "refseq_ncrna", all.x = TRUE)
nc <- fillMissingSymbol(nc)
#rm(res2)
#Assemble mRNA and ncRNA
counts.df <- rbind(pcg, nc)
rm(pcg)
rm(nc)

ercc.df <- data.frame(ercc.df, hgnc_symbol = ercc.df$ercc.id, stringsAsFactors = FALSE)
colnames(ercc.df) <- gsub("ercc.id", "id", colnames(ercc.df))
colnames(counts.df) <- gsub("Length", "length", colnames(counts.df))
counts.df <- rbind(ercc.df, counts.df)

dataCols <- grep("sr|sen|rej", colnames(counts.df), perl = TRUE)
annoCols <- grep("id|symbol|length", colnames(counts.df), perl = TRUE)

groups <- colnames(counts.df)[dataCols]
groups <- gsub("_[0-9]+", "", groups)
groups <- factor(groups, levels = unique(groups))
```

```{r message = FALSE}
library(edgeR)
dge <- DGEList(counts = counts.df[, dataCols], group = groups, genes = counts.df[, annoCols])
```

## Filtering Low Expression Sequences


```{r FilterCounts, fig.width = 6}
#Filter Low Count Seqeunces
#keep <- apply(dge$counts, 1, min) > 3
keep <- rowSums(cpm(dge) > 1) >= 1
dge <- dge[keep, ]

plotDistribution(dge$counts, "Distribution of Filtered Counts")

counts.df <- data.frame(dge$counts, dge$genes)
```

After filtering, **`r sum(keep)`** transcripts were kept for downstream analysis.

## Expression of Genes
Since different RefSeq transcripts for the same gene symbol shares most of their reads, therefore, among the **`r nrow(counts.df)`** transcripts, the transcript with highest overall count for each gene symbol were used for that particular gene symbol. 

```{r getGeneExpression}
o <- order(rowSums(dge$counts), decreasing = TRUE)
dge <- dge[o, ]
dge <- dge[! duplicated(dge$genes$hgnc_symbol), ]

dge$samples$lib.size <- colSums(dge$counts)
```


## Normalize against beta-actin(ACTB)

```{r}
actb <- counts.df[counts.df$hgnc_symbol == "ACTB", ]
actb.val <- unlist(actb[, grep("sr|sen|rej", colnames(actb), perl = TRUE)])
actb.sc <- actb.val/mean(actb.val)
```

```{r}
val <- grep("sr|sen|rej", colnames(counts.df), perl = TRUE)
nonval <- grep("sr|sen|rej", colnames(counts.df), perl = TRUE, invert = TRUE)
actb <- t(t(counts.df[, val])/actb.sc)
actb.df <- data.frame(actb, counts.df[, nonval])
```

```{r TMMDensity, fig.width = 6}
library(reshape)
library(ggplot2)

plotDistribution(actb, "ACTB Normalized Gene Expression")

plotDistribution(actb[grep("ERCC-", actb.df$hgnc_symbol), ], "ACTB Normalized ERCC Sequences")
```


# Calling Differential Expression with GFOLD

```{r cache = TRUE}
remote.gfold = "http://jordan.biology.gatech.edu/lulu/data/kazak.DEgenes.normbyACTB.xlsx"
dest.gfold = "./kazak_data/kazak.DEgenes.normbyACTB.xlsx"
download.file(remote.gfold, dest.gfold, mode = "wb")
##Manuall converted to csv due to large .xlsx file size
sr.gfold = "./kazak_data/kazak.DEgenes.normbyACTB-sr.csv"
sen.gfold = "./kazak_data/kazak.DEgenes.normbyACTB-sen.csv"
```

##SR treated vs SR untreated

```{r message = FALSE, cache = TRUE}
sr.ws <- read.csv(sr.gfold, header = TRUE)
```

```{r}
head(sr.ws)
```

```{r showGFOLD, eval = TRUE}
library(ggplot2)
library(reshape)

showData <- function(data){
    head(data)
    df <- melt(data[, 3:4])
    g <- qplot(df$variable, log2(df$value), data = df, geom = "boxplot", fill = df$variable, xlab = "", ylab = "log2 Counts")
    print(g)
    p <- qplot(log2(df$value), data = df, geom = "density", color = df$variable, xlab = "log2 Counts")
    p
}

showData(sr.ws)
```


##SEN treated vs SEN untreated

```{r message = FALSE, cache = TRUE}
sen.ws <- read.csv(sen.gfold, header = TRUE)
```

```{r}
head(sen.ws)
```

```{r eval = TRUE}
showData(sen.ws)
```

## Hierachical Clustering

```{r hclust}
mdf <- merge(sr.ws, sen.ws, by.x = "RefSeq.ID", by.y = "RefSeq.ID")
colnames(mdf) <- gsub("\\.x", "\\.sr", colnames(mdf))
colnames(mdf) <- gsub("\\.y", "\\.sen", colnames(mdf))

gfold.df <- mdf[, grep("Gene.Symbol.sen", colnames(mdf), invert = TRUE)]
gfold.exprs <- grep("SR|SEN", colnames(gfold.df), perl = TRUE)


gfold.up.union = (gfold.df$GFOLD.sr > 0.01 | gfold.df$GFOLD.sen > 0.01)
gfold.up.sr = (gfold.df$GFOLD.sr > 0.01 & gfold.df$GFOLD.sen <= 0.01)
gfold.up.sen = (gfold.df$GFOLD.sr <= 0.01 & gfold.df$GFOLD.sen > 0.01)
gfold.up.intersect = (gfold.df$GFOLD.sr > 0.01 & gfold.df$GFOLD.sen > 0.01)


gfold.dn.union = (gfold.df$GFOLD.sr < -0.01 | gfold.df$GFOLD.sen < -0.01)
gfold.dn.sr = (gfold.df$GFOLD.sr < -0.01 & gfold.df$GFOLD.sen >= -0.01)
gfold.dn.sen = (gfold.df$GFOLD.sr >= -0.01 & gfold.df$GFOLD.sen < -0.01)
gfold.dn.intersect = (gfold.df$GFOLD.sr < -0.01 & gfold.df$GFOLD.sen < -0.01)
```

Hierarchical clustering was performed and heatmap was generated to visualize gene clusters. 8 heatmaps were generated for

Set Name | Number of Gene
---- | ----
Union of up-regulated genes in SR treated and SEN treated | `r sum(gfold.up.union)`
Genes up-regulated in SR treated only | `r sum(gfold.up.sr)`
Genes up-regulated in SEN treated only | `r sum(gfold.up.sen)`
Intersection of up-regulated genes in SR treated and SEN treated | `r sum(gfold.up.intersect)`
Union of down-regulated genes in SR treated and SEN treated | `r sum(gfold.dn.union)`
Genes down-regulated in SR treated only | `r sum(gfold.dn.sr)`
Genes down-regulated in SEN treated only | `r sum(gfold.dn.sen)`
Intersection of down-regulated genes in SR treated and SEN treated | `r sum(gfold.dn.intersect)`


```{r plot8heatmap}
ggheat = function(m, rescaling='none', clustering='none', labCol=T, labRow=T, border=FALSE, heatscale= c(low='blue',high='red')) {
  ## the function can be be viewed as a two step process
  ## 1. using the rehape package and other funcs the data is clustered, scaled, and reshaped
  ## using simple options or by a user supplied function
  ## 2. with the now resahped data the plot, the chosen labels and plot style are built
 
  require(reshape)
  require(ggplot2)
 
  ## you can either scale by row or column not both! 
  ## if you wish to scale by both or use a differen scale method then simply supply a scale
  ## function instead NB scale is a base funct
 
  if(is.function(rescaling))
  { 
    m=rescaling(m)
  } 
  else 
  {
    if(rescaling=='column') 
      m=scale(m, center=T)
    if(rescaling=='row') 
      m=t(scale(t(m),center=T))
  }
 
  ## I have supplied the default cluster and euclidean distance- and chose to cluster after scaling
  ## if you want a different distance/cluster method-- or to cluster and then scale
  ## then you can supply a custom function 
 
  if(is.function(clustering)) 
  {
    m=clustering(m)
  }else
  {
  if(clustering=='row')
    m=m[hclust(dist(m))$order, ]
  if(clustering=='column')  
    m=m[,hclust(dist(t(m)))$order]
  if(clustering=='both')
    m=m[hclust(dist(m))$order ,hclust(dist(t(m)))$order]
  }
  ## this is just reshaping into a ggplot format matrix and making a ggplot layer
 
  rows=dim(m)[1]
  cols=dim(m)[2]
  melt.m=cbind(rowInd=rep(1:rows, times=cols), colInd=rep(1:cols, each=rows) ,melt(m))
	g=ggplot(data=melt.m)
 
  ## add the heat tiles with or without a white border for clarity
 
  if(border==TRUE)
    g2=g+geom_rect(aes(xmin=colInd-1,xmax=colInd,ymin=rowInd-1,ymax=rowInd, fill=value),colour='white')
  if(border==FALSE)
    g2=g+geom_rect(aes(xmin=colInd-1,xmax=colInd,ymin=rowInd-1,ymax=rowInd, fill=value))
 
  ## add axis labels either supplied or from the colnames rownames of the matrix
 
  if(labCol==T) 
    g2=g2+scale_x_continuous(breaks=(1:cols)-0.5, labels=colnames(m))
  if(labCol==F) 
    g2=g2+scale_x_continuous(breaks=(1:cols)-0.5, labels=rep('',cols))
 
  if(labRow==T) 
    g2=g2+scale_y_continuous(breaks=(1:rows)-0.5, labels=rownames(m))	
	if(labRow==F) 
    g2=g2+scale_y_continuous(breaks=(1:rows)-0.5, labels=rep('',rows))	
 
  ## get rid of grey panel background and gridlines
 
  g2=g2+opts(panel.grid.minor=theme_line(colour=NA), panel.grid.major=theme_line(colour=NA),
  panel.background=theme_rect(fill=NA, colour=NA))
 
  ## finally add the fill colour ramp of your choice (default is blue to red)-- and return
  return(g2+scale_fill_continuous("", heatscale[1], heatscale[2]))
 
}



library(gplots)
hmcol = colorRampPalette(c("steelblue", "white", "darkred"))(100)
plotHeatmap <- function(data, colIndex, rowIndex, title){
    mat <- as.matrix(data[rowIndex, colIndex])
   zmat <- (mat - rowMeans(mat))/apply(mat, 1, sd)
    heatmap.2(zmat, 
              col = hmcol, 
              trace = "none", 
              scale = "none",
              labRow = data[, grep("Symbol", colnames(data))],
              margin = c(15, 6),
              keysize = 1.5,
              density.info = "none",
              key.title = "z-score",
              key.xlab = "z-score",
              main = title)
}


## Down Treated

pdf("SR Treated Down Only.pdf", height = 100 , width = 5)
plotHeatmap(gfold.df, gfold.exprs, gfold.dn.sr, "SR Treated Down Only")
dev.off()

pdf("SEN Treated Down Only.pdf", height = 300 , width = 5)
plotHeatmap(gfold.df, gfold.exprs, gfold.dn.sen, "SR Treated Down Only")
dev.off()

pdf("Treated Down Intersect.pdf", height = 15, width = 5)
plotHeatmap(gfold.df, gfold.exprs, gfold.dn.intersect, "Treated Down Intersect")
dev.off()

```

# Expression Level of Individual Genes/Sequences

```{r IndividualGeneExpression, message = FALSE, fig.width = 10, fig.height = 4, warnings = FALSE}
library(bear)
#c6 <- c6.container
plotGenes <- function(x, data, dataset = "", groups){
    values <- data[data$hgnc_symbol == x, ]
    dataset <- ifelse(nchar(dataset) == 0, dataset, paste(" from ", dataset))
    if(nrow(values) == 0){
        print(paste("No data found for ", x))
    }
    else{
        cols <- grep("sr|sen|rej", colnames(values), perl = TRUE)
        
        values <- as.numeric(unlist(values)[cols])
        values.df <- data.frame(values, groups)
        sum.var <- summarySE(values.df, measurevar = "values", groupvars = "groups")
        
        g <- ggplot(sum.var, aes(x = factor(groups), y = values, fill = groups)) +
            geom_bar(stat = "identity") +
            geom_errorbar(aes(ymin = values - se, ymax = values + se),
                          size = 0.2,
                          width = 0.2) +
            scale_fill_manual(values = c6) +
            labs(title = paste(x, dataset), x = "", y = "Counts") + 
        theme_bw() +
        theme(panel.grid.major = element_blank(), 
              legend.position = "none",
              axis.text.x = element_text(angle = 45, hjust = 1))
        return(g)
    }
}



multiplot <- function(..., plotlist = NULL, file, cols = 1, layout = NULL) {
      require(grid)
    
      plots <- c(list(...), plotlist)
    
      numPlots = length(plots)
    
      if (is.null(layout)) {
        layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                        ncol = cols, nrow = ceiling(numPlots/cols))
      }
    
      if (numPlots == 1) {
        print(plots[[1]])
    
      } else {
        grid.newpage()
        pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
    
        for (i in 1:numPlots) {
          matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
    
          print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                          layout.pos.col = matchidx$col))
        }
      }
}

old.hk <- c("GAPDH", "RPL13A", "ACTB")

datasets <- list(counts.df, actb.df)
setnames <- c("Raw", "ACTB nm.")
names(datasets) <- setnames

plotMore <- function(datasets, setnames, genes){
    res <- lapply(genes, plotGenes, datasets, setnames, groups = groups)
    multiplot(plotlist = res, cols = 3 )
}

```

```{r message = FALSE, warning = FALSE, fig.height = 3, fig.wdith = 14}
Map(plotMore, datasets, setnames, rep(list(old.hk), length(datasets)))
```


## Downloadable Files

```{r}
write.csv(actb.df, "actb.normalized.counts.csv", quote = FALSE, row.names = FALSE)
```


# Meeting Notes

[20140523][002]

[20140606][003]

[20140828][004]


[img01]:Kazak_Overall_experimental_design.jpg

[f001]:./data/kazak.DE.pcg.GFOLD.xlsx

[001]:http://www.lifetechnologies.com/order/catalog/product/4456740
[002]:./slides/20140523.Overall_analytical_design.pdf
[003]:./slides/20140606.ERCC.pdf
[004]:./slides/20140828.Normalization_of_kazak_RNA-seq_data.pdf
